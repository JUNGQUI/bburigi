# bburigi

안녕하세요, 2020 카카오페이 경력직 공채 서버 개발 부문 응시자 이정기 입니다.

우선 요구 사항에 대해 정리를 했습니다.
뿌리기 요청 건 - 이하 뿌리기
각 금액 받기 요청 건 - 이하 요청 건

1. token 은 유니크
2. 뿌리기를 만들면서 요청 건 저장, 뿌리기와 요청 건 은 relation 존재
3. 요청 금액에서 뿌리기 를 접근하지 않음
4. 만료일 존재
5. 뿌릴 때는 logic 이 존재하지 않음 (임의 금액, 차액이 남아도 됨, 나누는 로직 없음) - 요청 건 제약 조건 약함

이와 같은 방식으로 Entity 를 먼저 생각하면서 정리를 했습니다.

그렇게 하여 JPA 로 구성을 하며 공통으로 쓸 수 있는 부분들에 대해서 embedded 형태로 정리 했고
일급 class 를 지향하여 entity 및 table 을 구성했습니다.

#1. 뿌리기 API

뿌리기 생성 시 token 이 유니크해야 하기 때문에 token 생성 후 검색을 하게 하였습니다.
또한 해당 생성 시 method 에 대해 timeout 을 발생하게 하여 단 기간 내에 생성하지 못할 경우 다시 요청하게 했습니다.

token 을 가져올 때는 apache common lang을 가져왔는데, 별도의 설정 없이 가져올 경우 중문도 사용 가능해서 추후 token 부족 시 사용 할 수 있지 않을까 합니다.

#2. 받기 API

제약 조건이 5가지 있었는데,

1. 누구에게도 할당되지 않은 건 -> owner 가 없음
2. 그 건에 대해 내가 사용하지 않았던 건 -> 내가 owner 인 요청 건이 없어야 함
3. 내가 뿌리지 않은 건 -> 요청 건 중 sourceUser 가 내 것이 아니여야 함
4. 동일한 대화방 -> 요청 건 중 roomId 가 동일해야 함
5. 만료는 10분 -> expire date 필요

1번, 2번, 3번으로 인해 요청 건 entity 에는 뿌리기의 userId 와 요청 건의 userId 가 별도로 존재해야 했습니다.

사실 4번의 경우, token 이 유니크함이 보장되기 때문에 별도로 체크할 필요가 없을 것 같습니다. 하지만 제약 조건에 존재하기 때문에 추가하였습니다.

5번의 경우 뿌리기와 마찬가지로 만료 기간이 있기 때문에 공통 embedded 로 묶어서 사용했습니다.


단순 JPARepository 만으로 사용하기엔 method 명칭이 길어지기 때문에 JPQL 형식으로 customizing 하였고, 
이렇게 JPQL이 사용된 부분은 추후 유지 보수를 위해 DynamicRepository 라는 class 를 만들어 관심사를 분리하였습니다.


#3. 조회 API

뿌리기에 종속된 모든 요청 건이 아닌, 실제 금액이 나간 요청 건만 별도로 보여줘야 하는 제약 조건이 있었습니다.

이러한 부분 해결을 위해 DTO 와 DAO 를 분리하였고, JPA 특성 상 뿌리기 - 요청 건 이 묶여 있기 때문에 호출을 통해 가져와서 
WAS layer 에서 분리, 분해 하여 DTO 로 재구성해서 return 하게 만들었습니다.